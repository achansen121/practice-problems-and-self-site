


var promise=function(loc,key){
  if(loc[key]!==undefined)
    return loc[key];
  var o={subscribe:function(fnc){
      if(!this.done)
        this.f_to_call.push(fnc);
      else
        fnc(this.error,this.result);
      return this;
    },f_to_call:[],done:false,result:false,error:false,time_stamp:0,finish_time:0,
    finish:function(err,data,options){
      if(this.done)
        throw new Error("finished twice");
      this.done=true;
      this.finish_time=(new Date()).getTime();
      this.result=data;
      this.error=err;
      var exf=this.f_to_call.shift();
      while(exf){
        exf(err,data);
        exf=this.f_to_call.shift();
      };
      if(options&&options.dt){
        setTimeout(function(){
          o.delete_self();
          },options.dt);
      }
      else
        setTimeout(function(){
          o.delete_self();
          },7000);
    },
    delete_self:function(){
      if(loc[key]==this)
        delete loc[key];
    },
    ensure_terminate:function(fnc){
      if(this.will_terminate||this.done)
        return this;
      else{
        this.will_terminate=true;
        fnc(this);}
      return this;
    }
    ,
    will_terminate:false,loc:loc,key:key,
  };
  loc[key]=o;
  o.time_stamp=(new Date()).getTime();
  var same=o.time_stamp;

  setTimeout(function(){
    if(loc[key])
      if(same===loc[key].time_stamp&&!loc[key].done){
        loc[key].finish(new Error("broken promise"),false);
        console.log("Broken Promise");
        console.log(key);
        console.log(JSON.stringify([loc[key].done,loc[key].will_terminate,same]));
      }
  },5*1000);

  return o;
};

module.exports=promise;